%!TEX root = paper.tex
%
% Development Approach
%
% Lead currently:  Aron Ahmadia's
%

\section{Development Approach}

\clawpack's development model is driven by the needs of its
developer community.  The \clawpack project consists of several
interdependent projects: core solver functionality, a
visualization suite, a general adaptive mesh refinement code, a
specialized geophysical flow code, and a massively parallel Python
framework.  Changes to the core solvers and visualization suite have a
downstream effect on the other codes, and the developers largely work
in an independent, asynchronous manner across continents and time
zones.

\vskip 5pt
The core \clawpack software repositories are:
\begin{itemize}
    \item \texttt{clawpack} - Installation, coordination of other repositories,
    \item \texttt{riemann} - Riemann solvers used by all the other projects,
    \item \texttt{visclaw} - Visualization suite used by all the other projects,
    \item \texttt{clawutil} - Utility functions used by most other projects,
    \item \texttt{classic} - Single grid methods in 1, 2, and 3 space
    dimensions,
    \item \texttt{amrclaw} - Adaptive mesh refinement (AMR) in 2 and 3 dimensions,
    \item \texttt{geoclaw} - AMR codes for depth-averaged geophysical flows,
    \item \texttt{pyclaw} - Python implementation and interface to the \clawpack algorithms including massively parallel capabilities.
\end{itemize}

\noindent
A release of \clawpack downloaded by users contains all of the above.
We sometimes refer to \texttt{riemann}, \texttt{visclaw}, and
\texttt{clawutil} as \textit{upstream} projects, since their changes
affect the remaining projects \comment{(repository?)} in the list, which
we usually refer to as \textit{downstream} projects
\comment{(repository?)}.  \comment{DAC : Do changes in visclaw really
affect, for example, amrclaw? Maybe the categories could be called
utilities, core routines (upstream) and applications (downstream)?}

Additional repositories contain documentation and extended examples of
using the code:
\begin{itemize}
    \item \texttt{doc} - Documentation source files, developed using
Sphinx\footnote{\url{http://sphinx-doc.org}},
    \item \texttt{clawpack.github.com} - Documentation html files that appear
at \url{http://www.clawpack.org},
    \item \texttt{apps} - Applications contributed by developers and users
that go beyond the introductory examples included in the core repositories.
\end{itemize}
Clawpack 4.x is still available in the repository
\begin{itemize}
    \item \texttt{clawpack-4.x}
\end{itemize}
but is no longer under development.


\subsection{Version Control}

The \clawpack team leverages the Git distributed version control system
to coordinate development, with each major project and its development
team assigned to its own repository.  The repositories are each
publicly coordinated under the \clawpack organization on
GitHub\footnote{\url{https://github.com/clawpack}} and the
top-level \texttt{clawpack} super-repository is responsible for hosting
build and installation tools, as well as providing a synchronization
point for the other repositories.  The remaining ``core \clawpack repositories''
listed above are subrepositories of \texttt{clawpack}.

GitHub is a free provider of public Git repositories.  In addition to
repository hosting, the \clawpack team uses GitHub for issue tracking,
code review, automated continuous integration via Travis CI\footnote{\url{https://travis-ci.org/}},
and test coverage tracking via Coveralls\footnote{\url{http://coveralls.io}}
for the Python-based modules.  The issue tracker on
GitHub automatically recognizes cross-repository references,
simplifying communication between \clawpack developer sub-teams.  The
Travis CI service, which provides free continuous integration for
publicly developed repositories on GitHub, runs \clawpack's test
suites through \texttt{nose}\footnote{\url{https://nose.readthedocs.org}}
on proposed changes
to the code base, and through a connection to the Coveralls service,
reports on any test failures as well as changes to test coverage.

\subsection{Submodules}

As mentioned earlier, the \texttt{clawpack} repository serves as an
installation and synchronization point for the other project repositories.
Snapshots of the top-level repository are taken both to prepare for
software releases of the Clawpack project itself, and to provide
``known working states'' when changes from upstream repositories must
be coordinated with their downstream consumers.

Typically, the \clawpack developers advance the master development
branch of the top-level repository any time a major feature is added
or a bug is fixed in one of the other projects.  When a feature is
added to an upstream repository that affects other repositories, the
addition of this change is coordinated with the downstream
repositories by simultaneously advancing the version of the upstream
repository as well as all affected downstream repositories.

Developers, both new and experienced, may find Git submodules challenging
to work with, but they are very powerful and
have proved invaluable in allowing the \clawpack team to
work asynchronously on independent projects while reusing and maintaining
common software infrastructure.


\subsection{Contributing}

Scientist programmers are often discouraged from sharing code
due to existing reward mechanisms and the fear of being ``scooped''.
In fact, scientific communities that openly share and develop code
have an advantage because each researcher can leverage the work of
many others \cite{Turk:2013hd}.

Over the past twenty years, a great number of users have written
additional code, extending \clawpack with new Riemann solvers,
algorithms, and domain-specific problem tools.  Most of this code
has not made it back into the core library.  With \clawpack 5.x,
we are trying to encourage contributions from a broad community, with
tools like distributed version control and open discussions on
the mailing lists and issue trackers.

The primary development model is typical for GitHub projects: a
contributor forks the repository on GitHub, then develops improvements
in a branch that is pushed to her own fork.  She issues a ``pull
request'' (PR) when the branch is ready to be merged into the main
repository.  Increasingly, contributors are also using PRs as a way to
conveniently post preliminary or prototype code for discussion prior
to further development, often marked WIP for ``work in progress'' to signal
that it is not ready to merge.

After a PR is issued, other developers -- including one or more of the
maintainers for the corresponding project -- review the code.  The Travis
CI server also automatically runs the tests on the proposed new code.  The test
results are visible on the GitHub page for the PR.  Usually there is
some iteration as developers suggest improvements or discuss
implementation choices in the code.  Once the tests are passing and it
is agreed that the code is acceptable, a maintainer merges it.

\subsection{Releases}

Although \clawpack is continuously developed, it is convenient for
users to be able to install stable versions of the software.  The
\clawpack developers provide these releases through two distribution
channels: GitHub and the Python Package Index (PyPI).  Full source
releases are available on GitHub.  Alternatively, the PyClaw
subproject and its dependencies can be installed automatically using a
PyPI client such as \texttt{pip}. \comment{DAC :
Can Clawpack also be installed using pip?  From the way it is written,
it sounds like only PyClaw can be installed using pip.}

\clawpack does not follow a calendar release cycle.  Instead, releases
emerge when the developer community feels enough changes have
accumulated since the last release to justify
the cost of switching to a new release.  \clawpack releases are
versioned using an $M.m.p$ triplet, representing the major (M), minor (m), and
patch (p) versions respectively.  In the broader software engineering
community, this is often referred to as semantic versioning.  Small
changes that fix bugs and cosmetic issues result in increments to the
patch-level.  Backwards-compatible changes result in an increase to
the minor version.  The introduction of backwards-incompatible changes
require that the major version be incremented.  In addition, the
implementation of significant new algorithms or capability will also
justify the increment of major release number, and is often an impetus
for providing another release to the public.
